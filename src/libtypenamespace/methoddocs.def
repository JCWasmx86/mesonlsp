@bool::to_int:
Returns `1` if `true` and `0` if `false`.
@bool::to_string:
Returns the string `'true'` if the boolean is true or `'false'` otherwise. Additionally, you can pass two strings as positional arguments to specify what to return for true/false.
For example, `bool.to_string('yes', 'no')` will return `'yes'` if the boolean is true and `'no'` if it is false.
@both_libs::get_shared_lib:
Returns the stored shared library
@both_libs::get_static_lib:
Returns the stored static library
@build_machine::cpu:
Returns a more specific CPU name, such as `i686`, `amd64`, etc.
@build_machine::cpu_family:
Returns the CPU family name. [This table](https://mesonbuild.com/Reference-tables.html#cpu-families) contains all known CPU families. These are guaranteed to continue working.
@build_machine::endian:
Returns `'big'` on big-endian systems and `'little'` on little-endian systems.
@build_machine::system:
Returns the operating system name. [This table](https://mesonbuild.com/Reference-tables.html#operating-system-names) lists all of the currently known Operating System names, these are guaranteed to continue working.
@build_tgt::extract_all_objects:
Acts the same as `extract_objects`, but returns all object files generated by this target.

By default only objects built for this target are returned to maintain backward compatibility with previous versions. The default value for the `recursive` kwarg will eventually be changed to `true` in a future version.
@build_tgt::extract_objects:
Returns an opaque value representing the object files generated for those source files. This is typically used to take single object files and link them to unit tests or to compile some source files with custom flags. To use the object file(s) in another build target, use the `objects:` keyword argument to a `build_target()` or `declare_dependency()`, or include them in the command line of a `custom_target()`.
@build_tgt::found:
Always returns `true`. This function is meant to make executables objects feature compatible with `external_program` objects. This simplifies use-cases where an executable is used instead of an `external_program`.
@build_tgt::full_path:
Returns a full path pointing to the result target file. **NOTE:** In most cases using the object itself will do the same job as this and will also allow Meson to setup inter-target dependencies correctly. Please file a bug if that doesn't work for you.
@build_tgt::outdir:
????
@build_tgt::name:
Returns the name of the target.
@build_tgt::path:
Does the exact same as `build_tgt.full_path()`. **NOTE:** This function is solely kept for compatibility with `external_program` objects. It will be removed once the, also deprecated, corresponding `path()` function in the `external_program` object is removed.
@build_tgt::private_dir_include:
Returns a value that works like `include_directories()`, but points to the private directory of this target. Usually only needed if an another target needs to access some generated internal headers of this target.
@cfg_data::get:
Returns the value of `varname`, if the value has not been set returns `default_value` if it is defined (since 0.38.0) and errors out if not.
@cfg_data::get_unquoted:
Returns the value of `varname` but without surrounding double quotes (`"`). If the value has not been set, it returns `default_value` if it is defined and errors out if not.
@cfg_data::has:
Returns `true` if the specified variable is set.
@cfg_data::keys:
Returns an array of keys of the configuration data object.
@cfg_data::merge_from:
Takes as argument a different configuration data object and copies all entries from that object to the current.
@cfg_data::set:
Sets a variable to a given value
@cfg_data::set10:
Is the same as `cfg_data.set()` but the value is either `true` or `false` and will be written as 1 or 0, respectively
@cfg_data::set_quoted:
Is same as `cfg_data.set()` but quotes the value in double quotes (`"`)
@cmake_module::subproject:
The `subproject` method is almost identical to the normal Meson `subproject()` function. The only difference is that a CMake project instead of a Meson project is configured.
@cmake_module::subproject_options:
Returns a `cmake_subprojectoptions` that is very similar to the `cfg_data` object.
@cmake_module::write_basic_package_version_file:
This method is the equivalent of the corresponding CMake function, generating a named package version file.

- `name`: the name of the package.
- `version`: the version of the generated package file.
- `compatibility`: a string indicating the kind of compatibility; accepted values are `AnyNewerVersion`, `SameMajorVersion`, `SameMinorVersion`, or `ExactVersion`. It defaults to `AnyNewerVersion`. Depending on your CMake installation, some compatibility types may not be available.
- `arch_independent`: new in 0.62.0, if true, the generated package file will skip architecture checks. This is useful for header-only libraries.
- `install_dir`: an optional installation directory; it defaults to `$(libdir)/cmake/$(name)`.
@cmake_module::configure_package_config_file:
This method is the equivalent of the corresponding CMake function. It generates a named package configuration file from the input template file. Similar to the CMake function in this file, the `@PACKAGE_INIT@` statement will be replaced by the appropriate piece of CMake code. The equivalent `PATH_VARS` argument is given through the `configuration` parameter.

- `name`: the name of the package.
- `input`: the template file where variables will be substituted based on the provided `configuration`.
- `install_dir`: an optional installation directory; it defaults to `$(libdir)/cmake/$(name)`.
- `configuration`: a `configuration_data` object used for variable substitution in the template file. Since 0.62.0, it can take a dictionary instead.

@cmake_subproject::dependency:
@cmake_subproject::include_directories:
Returns a Meson `inc` object for the specified target. Using this method is not necessary if the dependency object is used.
@cmake_subproject::target:
Returns the raw build target.
@cmake_subproject::target_type:
Returns the type of the target as a string
@cmake_subproject::target_list:
Returns a list of all target `name`s.
@cmake_subproject::found:
Returns `true` if the subproject is available, otherwise `false`.
@cmake_subproject::get_variable:
Fetches the specified variable from inside the subproject. Usually `dependency()` or `target()` should be preferred to extract build targets.
@cmake_subprojectoptions::add_cmake_defines:
Add additional CMake commandline defines
@cmake_subprojectoptions::set_override_option:
Set specific build options for targets. This will effectively add `opt=val` to the `override_options` array of the `build_target()`.
@cmake_subprojectoptions::set_install:
Override whether targets should be installed or not
@cmake_subprojectoptions::append_compile_args:
Append compile flags for a specific language to the targets
@cmake_subprojectoptions::append_link_args:
Append linker args to the targets.
@cmake_subprojectoptions::clear:
Reset all data in the cmake options object
@compiler::alignment:
Returns the alignment of the specified type. For C-like languages, the header `stddef.h` and `stdio.h` are included implicitly for native compilation, only `stddef.h` is included when cross-compiling.
@compiler::check_header:
Returns true if the specified header is usable with the specified prefix, dependencies, and arguments.
@compiler::has_define:
Returns `true` if the given preprocessor symbol is defined.
@compiler::cmd_array:
Returns an array containing the command(s) for the compiler.
@compiler::compiles:
Returns true if the code compiles.
@compiler::compute_int:
Computes the value of the given expression (for example, 1 + 2). When cross-compiling, this is evaluated with an iterative algorithm. You can specify the following keyword arguments:
- `low` (defaults to -1024)
- `high` (defaults to 1024)
- `guess` to specify max and min values for the search and the value to try first.

For C-like languages, the header `stddef.h` and `stdio.h` are implicitly included for native compilation, whereas only `stddef.h` is included when cross-compiling.
@compiler::find_library:
Tries to find the library specified in the positional argument.
@compiler::first_supported_argument:
Given a list of strings, returns a single-element list containing the first argument that passes the `compiler.has_argument()` test or an empty array if none pass.
@compiler::first_supported_link_argument:
Given a list of strings, returns the first argument that passes the `compiler.has_link_argument()` test or an empty array if none pass.
@compiler::get_argument_syntax:
returns a string identifying the type of arguments the compiler takes. Can be one of `gcc`, `msvc`, or an undefined string value. This method is useful for identifying compilers that are not gcc or msvc, but use the same argument syntax as one of those two compilers such as clang or icc, especially when they use different syntax on different operating systems.
@compiler::get_define:
Returns the given preprocessor symbol's value as a string or empty string if it is not defined.
@compiler::get_id:
Returns a string identifying the compiler. For example, `gcc`, `msvc`, and more.
@compiler::get_linker_id:
Returns a string identifying the linker. For example, `ld.bfd`, `link`, and more.
@compiler::get_supported_arguments:
Returns an array containing only the arguments supported by the compiler, as if `compiler.has_argument()` were called on them individually.
@compiler::get_supported_function_attributes:
Returns an array containing any names that are supported GCC style attributes. Equivalent to `compiler.has_function_attribute()` was called on each of them individually.
@compiler::get_supported_link_arguments:
Returns an array containing only the arguments supported by the compiler, as if `compiler.has_link_argument()` were called on them individually.
@compiler::has_argument:
Returns `true` if the compiler accepts the specified command line argument, that is, can compile code without erroring out or printing a warning about an unknown flag.
@compiler::has_function:
Returns true if the given function is provided by the standard library or a library passed in with the `args` keyword.
@compiler::has_function_attribute:
Returns true if the compiler supports the GNU style `(__attribute__(...))` `name`. This is preferable to manual compile checks as it may be optimized for compilers that do not support such attributes.
@compiler::has_header:
Returns true if the specified header is exists with the specified prefix, dependencies, and arguments.

This method is faster than `compiler.check_header()` since it only does a pre-processor check.
@compiler::has_header_symbol:
Detects whether a particular symbol is declared in the specified header.

Symbols here include function, variable, `#define`, type definition, etc.
@compiler::has_link_argument:
Returns true if the linker accepts the specified command line argument, that is, can compile and link code without erroring out or printing a warning about an unknown flag. Link arguments will be passed to the compiler, so should usually have the `-Wl,` prefix. On VisualStudio a `/link` argument will be prepended.
@compiler::has_member:
Returns true if the type has the specified member.
@compiler::has_members:
Returns true if the type has *all* the specified members.
@compiler::has_multi_arguments:
The same as `compiler.has_argument()` but takes multiple arguments and uses them all in a single compiler invocation.
@compiler::has_multi_link_arguments:
The same as `compiler.has_link_argument()` but takes multiple arguments and uses them all in a single compiler invocation.
@compiler::has_type:
Returns `true` if the specified token is a type.
@compiler::links:
Returns true if the code compiles and links.
@compiler::preprocess:
Preprocesses a list of source files but does not compile them. The preprocessor will receive the same arguments (include directories, defines, etc.) as with normal compilation. This includes, for example, arguments added with `add_project_arguments()`, or those set on the command line using `-Dc_args=-DFOO`.
@compiler::run:
Attempts to compile and execute the given code fragment.
@compiler::sizeof:
Returns the size of the given type (e.g., 'int') or -1 if the type is unknown. For C-like languages, the header `stddef.h` and `stdio.h` are included implicitly for native compilation, whereas only `stddef.h` is included when cross-compiling.
@compiler::symbols_have_underscore_prefix:
Returns true if the C symbol mangling is one underscore (`_`) prefixed to the symbol.
@compiler::version:
Returns the compiler's version number as a string.
@cuda_module::min_driver_version:
Returns the minimum NVIDIA proprietary driver version required, on the host system, by kernels compiled with a CUDA Toolkit with the given version string.

The output of this function is generally intended for informative message printing, but could be used for assertions or to conditionally enable features known to exist within the minimum NVIDIA driver required.
@cuda_module::nvcc_arch_flags:
Returns a list of `-gencode` flags that should be passed to `cuda_args:` in order to compile a "fat binary" for the architectures/compute capabilities enumerated in the positional argument(s). These flags shall be acceptable to an NVCC with CUDA Toolkit version string `cuda_version_string`.

A set of architectures and/or compute capabilities may be specified by:
- The single positional argument `'All'`, `'Common'`, or `'Auto'`
- As (an array of):
    - Architecture names (`'Kepler'`, `'Maxwell+Tegra'`, `'Turing'`) and/or
    - Compute capabilities (`'3.0'`, `'3.5'`, `'5.3'`, `'7.5'`)

A suffix of `+PTX` requests PTX code generation for the given architecture. A compute capability given as `A.B(X.Y)` requests PTX generation for an older virtual architecture `X.Y` before binary generation for a newer architecture `A.B`.

Multiple architectures and compute capabilities may be passed in using:
- Multiple positional arguments
- Lists of strings
- Space (' '), comma (','), or semicolon (';') separated strings
@cuda_module::nvcc_arch_readable:
Has precisely the same interface as `nvcc_arch_flags()`, but rather than returning a list of flags, it returns a "readable" list of architectures that will be compiled for. The output of this function is solely intended for informative message printing.
@custom_idx::full_path:
Returns a full path pointing to the result target file. **NOTE:** In most cases using the object itself will do the same job as this and will also allow Meson to setup inter-target dependencies correctly. Please file a bug if that doesn't work for you.
@custom_tgt::index:
Returns an opaque object that references this target, and can be used as a source in other targets. When it is used as such it will make that target depend on this custom target, but the only source added will be the one that corresponds to the index of the custom target's output argument.
@custom_tgt::full_path:
Returns a full path pointing to the resulting target file. **NOTE:** In most cases, using the object itself will accomplish the same task as this function and will also allow Meson to set up inter-target dependencies correctly. Please file a bug if that doesn't work for you. (since 0.54.0) It can also be called on index objects: `custom_targets[i].full_path()`.
@custom_tgt::to_list:
Returns a list of opaque objects that references this target, and can be used as a source in other targets.
@dep::as_link_whole:
Only dependencies created with `declare_dependency()`. Returns a copy of the dependency object with all `link_with` arguments changed to `link_whole`. This is useful, for example, for a fallback dependency from a subproject built with `default_library=static`. Note that all `link_with` objects must be static libraries; otherwise, an error will be raised when attempting to `link_whole` a shared library.
@dep::as_system:
Returns a copy of the dependency object, modifying the value of `include_type` to `value`. The `value` argument is optional and defaults to `'preserve'`.
@dep::found:
Returns whether the dependency was found.
@dep::get_configtool_variable:
Gets the command line argument from the config tool (with `--` prepended), or, if invoked on a non config-tool dependency, error out.
@dep::get_pkgconfig_variable:
Gets the pkg-config variable specified, or, if invoked on a non pkg-config dependency, error out.
@dep::get_variable:
A generic variable getter method, replacing the `get_*type*_variable` methods. This method enables retrieval of the variable from a dependency without requiring specific knowledge of how that dependency was found. If `default_value` is set and the value cannot be retrieved from the object, then `default_value` is returned. If it is not set, an error is raised.
@dep::include_type:
Returns the value set by the `include_type` kwarg.
@dep::name:
Returns the name of the dependency that was searched. Returns `'internal'` for dependencies created with `declare_dependency()`.
@dep::partial_dependency:
Returns a new dependency object with the same name, version, found status, type name, and methods as the object that called it. This new object will only inherit other attributes from its parent as controlled by keyword arguments.
@dep::type_name:
Returns a string describing the type of the dependency, the most common values are `internal` for deps created with `declare_dependency()` and `pkgconfig` for system dependencies obtained with Pkg-config.
@dep::version:
the version number as a string, for example `1.2.8`. `unknown` if the dependency provider doesn't support determining the version.
@dict::get:
Returns the value for the key given as first argument if it is present in the dictionary, or the optional fallback value given as the second argument. If a single argument was given and the key was not found, causes a fatal error
@dict::has_key:
Returns true if the dictionary contains the key given as argument, false otherwise.
@dict::keys:
Returns an array of keys in the dictionary.
@disabler::found:
Always returns `false`
@dlang_module::generate_dub_file:
This method only has two required arguments, the project name and the source folder. You can pass other arguments with additional keywords, they will be automatically translated to json and added to the `dub.json` file.
@env::append:
Appends the given values to the old value of the environment variable. For example, `env.append('FOO', 'BAR', 'BAZ', separator: ';')` produces `BOB;BAR;BAZ` if `FOO` had the value `BOB`, and plain `BAR;BAZ` if the value was not defined.
@env::prepend:
Same as `append` except that it writes to the beginning of the variable.
@env::set:
Sets the environment variable specified in the first argument to the values in the varargs joined by the separator. For instance, `env.set('FOO', 'BAR')` sets environment variable `FOO` to value `BAR`.
@external_program::found:
Returns whether the executable was found.
@external_program::full_path:
Returns a string pointing to the script or executable.

**NOTE:** You should not usually need to use this method. Passing the object itself should work in most contexts where a program can appear, and allows Meson to setup inter-target dependencies correctly (for example in cases where a program might be overridden by a `build_tgt`). Only use this if you specifically need a string, such as when embedding a program path into a header file.
@external_program::path:
Returns a string pointing to the script or executable.

**NOTE:** You should not usually need to use this method. Passing the object itself should work in most contexts where a program can appear, and allows Meson to setup inter-target dependencies correctly (for example in cases where a program might be overridden by a `build_tgt`). Only use this if you specifically need a string, such as when embedding a program path into a header file.
@external_program::version:
The version number as a string, for example `1.2.8`.

Returns `'unknown'` if the program cannot determine the version via a `--version` argument.
@external_project::dependency:
Return a dependency object that can be used to build targets against a library from the external project.
@external_project_module::add_project:
This function should be called at the root directory of a project using another build system. Usually in a `meson.build` file placed in the top directory of a subproject, but could be also in any subdir.
@feature::allowed:
Returns whether the feature was set to 'enabled' or 'auto'.
@feature::auto:
Returns whether the feature was set to 'auto'.
@feature::disable_auto_if:
Returns the feature, with 'auto' converted to 'disabled' if value is true.
@feature::disable_if:
Returns the object itself if the value is false; an error if the object is 'enabled' and the value is true; a disabled feature if the object is 'auto' or 'disabled' and the value is true.
@feature::disabled:
Returns whether the feature was set to 'disabled'
@feature::enable_auto_if:
Returns the feature, with 'auto' converted to 'enabled' if value is true.
@feature::enable_if:
Returns the object itself if the value is false; an error if the object is 'disabled' and the value is true; an enabled feature if the object is 'auto' or 'enabled' and the value is true.
@feature::enabled:
Returns whether the feature was set to 'enabled'
@feature::require:
Returns the object itself if the value is true; an error if the object is 'enabled' and the value is false; a disabled feature if the object is 'auto' or 'disabled' and the value is false.
@fs_module::exists:
Takes a single string argument and returns true if an entity with that name exists on the file system. This can be a file, directory or a special entry such as a device node.
@fs_module::is_dir:
Takes a single string argument and returns true if a directory with that name exists on the file system.
@fs_module::is_file:
Takes a single string argument and returns true if an file with that name exists on the file system.
@fs_module::is_symlink:
Takes a single string or (since 0.59.0) `files()` argument and returns true if the path pointed to by the string is a symbolic link.
@fs_module::is_absolute:
Return a boolean indicating if the path string or (since 0.59.0) `files()` specified is absolute, WITHOUT expanding `~`.
@fs_module::relative_to:
Return a relative filepath. In the event a relative path could not be found, the absolute path of `to` is returned. Relative path arguments will be assumed to be relative to `meson.current_source_dir()`.
@fs_module::hash:
The `fs.hash(filename, hash_algorithm)` method returns a string containing the hexadecimal `hash_algorithm` digest of a file. `hash_algorithm` is a string, and the available hash algorithms include: `md5`, `sha1`, `sha224`, `sha256`, `sha384`, `sha512`.
@fs_module::size:
The `fs.size(filename)` method returns the size of the file in integer bytes.
@fs_module::is_samepath:
The `fs.is_samepath(path1, path2)` returns a boolean `true` if both paths resolve to the same path. 

For example, suppose `path1` is a symlink and `path2` is a relative path. If `path1` can be resolved to `path2`, then `true` is returned. If `path1` is not resolved to `path2`, `false` is returned. If `path1` or `path2` do not exist, `false` is returned.
@fs_module::expanduser:
A path string with a leading `~` is expanded to the user home directory
@fs_module::as_posix:
The `fs.as_posix(path)` function assumes a Windows path, even if on a Unix-like system. Consequently, all `'\'` or `'\\'` characters are converted to `'/'`, even if you intended to escape a character.
@fs_module::replace_suffix:
The `replace_suffix` method is a string manipulation convenient for filename modifications. It allows changing the filename suffix like:
@fs_module::parent:
Returns the parent directory (i.e. dirname).
@fs_module::name:
Returns the last component of the path (i.e. basename).
@fs_module::stem:
Returns the last component of the path, dropping the last part of the suffix
@fs_module::read:
`read(path, encoding: 'utf-8')` (since 0.57.0): Returns a string with the contents of the given path. If the `encoding` keyword argument is not specified, the file specified by `path` is assumed to be UTF-8 encoded. Binary files are not supported.

The provided paths should be relative to the current `meson.current_source_dir()` or an absolute path outside the build directory is accepted.

If the file specified by `path` changes, this will trigger Meson to reconfigure the project. 

If the file specified by `path` is a `files()` object, it cannot refer to a built file.
@fs_module::copyfile:
Copy a file from the source directory to the build directory at build time
@generator::process:
Takes a list of files, causes them to be processed and returns an object containing the result which can then, for example, be passed into a build target definition.
@gnome_module::compile_resources:
This function compiles resources specified in an XML file into code that can be embedded inside the main binary. Similar to a build target, it takes two positional arguments. 

- The first one is the name of the resource, and 
- the second is the XML file containing the resource definitions. 

If the name is `foobar`, Meson will generate a header file called `foobar.h`, which you can then include in your sources. The resources specified are automatically added as dependencies of the generated target.
@gnome_module::generate_gir:
Generates GObject introspection data.
@gnome_module::genmarshal:
Generates a marshal file using the `glib-genmarshal` tool. The first argument is the basename of the output files.
@gnome_module::mkenums:
Generates enum files for GObject using the `glib-mkenums` tool. The first argument is the base name of the output files, unless `c_template` and `h_template` are specified. In this case, the output files will be the base name of the values passed as templates.

This method is essentially a wrapper around the `glib-mkenums` tool's command line API. It is the most featureful method for enum creation.

Typically, you either provide template files or specify the various template sections manually as strings.

Most libraries and applications will be using the same standard template with only minor tweaks, in which case the `gnome.mkenums_simple()` convenience method can be used instead.

Note that if you `#include` the generated header in any of the sources for a build target, you must add the generated header to the build target's list of sources to codify the dependency. This is true for all generated sources, not just `mkenums`.
@gnome_module::mkenums_simple:
Generates enum `.c` and `.h` files for GObject using the `glib-mkenums` tool with the standard template used by most GObject-based C libraries. The first argument is the base name of the output files.

Note that if you `#include` the generated header in any of the sources for a build target, you must add the generated header to the build target's list of sources to codify the dependency. This is true for all generated sources, not just `mkenums_simple`.

The generated source file includes all headers passed to the `sources` keyword argument, using paths relative to the current build or source directory. That means targets compiling the generated source file must have the current directory in their `include_directories`. Since 1.3.0, sour
@gnome_module::compile_schemas:
When called, this method will compile the gschemas in the current directory. Note that this is not for installing schemas and is only useful when running the application locally for example during tests.
@gnome_module::gdbus_codegen:
Compiles the given XML schema into gdbus source code. Takes two positional arguments, the first one specifies the base name to use while creating the output source and header and the second specifies one XML file.
@gnome_module::generate_vapi:
Creates a VAPI file from gir. The first argument is the name of the library.
@gnome_module::yelp:
Installs help documentation for Yelp using itstool and gettext. The first argument is the project id.

Additionally, sources can be passed as additional positional arguments. This was, however, undocumented and never officially supported. Due to a longstanding bug, passing sources as a keyword argument will result in the positional argument sources to be ignored. since 0.60.0 A warning is raised in this case.
@gnome_module::gtkdoc:
Compiles and installs gtkdoc documentation into `prefix/share/gtk-doc/html`. Takes one positional argument: The name of the module.
@gnome_module::gtkdoc_html_dir:
Takes as argument a module name and returns the path where that module's HTML files will be installed.
@gnome_module::post_install:
Post-install update of various system wide caches.
@hotdoc_module::has_extensions:
Returns true if all the extensions where found, false otherwise.
@hotdoc_module::generate_doc:
Generates documentation using hotdoc and installs it into `$prefix/share/doc/html`.
@hotdoc_target::config_path:
Path to the generated `hotdoc` configuration file.
@i18n_module::gettext:
Sets up gettext localisation so that translations are built and placed into their proper locations during install. Takes one positional argument which is the name of the gettext module.
@i18n_module::merge_file:
This merges translations into a text file using `msgfmt`. See `custom_target()` for normal keywords. In addition it accepts these keywords:
@i18n_module::itstool_join:
This joins translations into a XML file using `itstool`. See `custom_target()` for normal keywords. In addition it accepts these keywords:
@icestorm_module::project:
The input to this function includes a set of Verilog files and a constraint file. It produces output files named projname.asc, projname.blif, and projname.bin. Additionally, it creates two run targets:

- `projname-time` for running timing analysis.
- `projname-upload` that uploads the generated bitstream to an FPGA device using the iceprog programming executable.
@int::is_even:
Returns true if the number is even.
@int::is_odd:
Returns true if the number is odd
@int::to_string:
Returns the value of the number as a string.
@java_module::generate_native_header:
This function will generate a header file for use in Java native module development by reading the supplied Java file for `native` method declarations.
@java_module::generate_native_headers:
This function will generate native header files for use in Java native module development by reading the supplied Java files for `native` method declarations.
@java_module::native_headers:
This function will generate native header files for use in Java native module development by reading the supplied Java files for `native` method declarations.
@keyval_module::load:
This function loads a file consisting of a series of `key=value` lines and returns a dictionary object.

`keyval.load()` makes no attempt at parsing the values in the file. Boolean and integer values are represented as strings, and strings retain any quoting present in the input file. It can be useful to create a `configuration_data()` object from the dictionary and use methods such as `get_unquoted()`.

Kconfig frontends typically use ".config" as the default name for the configuration file. However, placing the configuration file in the source directory limits the user to one configuration per source directory. To allow separate configurations for each build directory, following the Meson standard, `meson.build` should not hardcode ".config" as the argument to `kconfig.load()`. Instead, it should make the argument to `kconfig.load()` a project build option.
@list::contains:
Returns true if the array contains the object given as argument, false otherwise
@list::get:
Returns the object at the given index, negative indices count from the back of the array, indexing out of bounds returns the `fallback` value (since 0.38.0) or, if it is not specified, causes a fatal error
@list::length:
Returns the current size of the array / list.
@meson::add_devenv:
Add an `env` object (returned by `environment()`) to the list of environments that will be applied when using the `meson devenv` command line.

This feature is beneficial for developers who want to use the project without installing it. It is often necessary to set variables such as the path to the plugins directory, among others. Alternatively, a list or dictionary can be passed as the first argument.
@meson::add_dist_script:
Causes the script given as an argument to run during the `dist` operation after the distribution source has been generated but before it is archived. Please note that this runs the script file located in the staging directory, not the one in the source directory. If the script file cannot be found in the staging directory, it results in a hard error. The `MESON_DIST_ROOT` environment variable is set when `dist` scripts are run.

(since 0.54.0) The `MESON_SOURCE_ROOT` and `MESON_BUILD_ROOT` environment variables are set when `dist` scripts are run. They represent the path to the root source and build directory of the main project, even when the script comes from a subproject.

(since 0.58.0) This command can be invoked from a subproject. In earlier versions, it resulted in a hard error. Subproject `dist` scripts will only be executed when running `meson dist --include-subprojects`. The `MESON_PROJECT_SOURCE_ROOT`, `MESON_PROJECT_BUILD_ROOT`, and `MESON_PROJECT_DIST_ROOT` environment variables are set when `dist` scripts are run for subprojects. They are identical to `MESON_SOURCE_ROOT`, `MESON_BUILD_ROOT`, and `MESON_DIST_ROOT` for main project scripts, but for subproject scripts, they have the path to the root of the subproject appended, usually `subprojects/<subproject-name>`.

@meson::add_install_script:
Causes the script given as an argument to be run during the install step. This script will have the following environment variables set:
- `MESON_SOURCE_ROOT`
- `MESON_BUILD_ROOT`
- `MESON_INSTALL_PREFIX`
- `MESON_INSTALL_DESTDIR_PREFIX`
- `MESONINTROSPECT`

All positional arguments are passed as parameters.

(since 0.54.0) If `meson install` is called with the `--quiet` option, the environment variable `MESON_INSTALL_QUIET` will be set.

(since 1.1.0) If `meson install` is called with the `--dry-run` option, the environment variable `MESON_INSTALL_DRY_RUN` will be set.

Meson uses the `DESTDIR` environment variable as set by the inherited environment to determine the temporary installation location for files. Your install script must be aware of this while manipulating and installing files. The correct way to handle this is with the `MESON_INSTALL_DESTDIR_PREFIX` variable, which is always set and contains `DESTDIR` (if set) and `prefix` joined together. This is useful because both are usually absolute paths, and there are platform-specific edge cases in joining two absolute paths.

If needed, `MESON_INSTALL_PREFIX` is also always set and has the value of the `prefix` option passed to Meson.

`MESONINTROSPECT` contains the path to the introspect command that corresponds to the `meson` executable that was used to configure the build. This might be a different path than the first executable found in `PATH`. It can be used to query build configuration. Note that the value will contain many parts, for example, it may be `python3 /path/to/meson.py introspect`. The user is responsible for splitting the string into an array if needed by splitting lexically like a UNIX shell would. If your script uses Python, `shlex.split()` is the easiest correct way to do this.
@meson::add_postconf_script:
Runs the given command after all project files have been generated. This script will have the environment variables `MESON_SOURCE_ROOT` and `MESON_BUILD_ROOT` set.
@meson::backend:
Returns a string representing the current backend
@meson::build_root:
Returns a string with the absolute path to the build root directory. 

However, note that this function will return the build root of the parent project if called from a subproject, which might not be the desired behavior in most cases.

For subprojects, it's recommended to use:
- `meson.current_build_dir()`
- `meson.project_build_root()`

In rare cases where the root of the main project is explicitly needed, you can use `meson.global_build_root()`, which behaves similarly but has a more explicit name.

@meson::build_options:
Returns a string with the configuration line used to set the current project up.
@meson::can_run_host_binaries:
Returns true if the build machine can run binaries compiled for the host. This returns true unless you are cross compiling, need a helper to run host binaries, and don't have one. For example when cross compiling from Linux to Windows, one can use wine as the helper.
@meson::current_build_dir:
Returns a string with the absolute path to the current build directory.
@meson::current_source_dir:
Returns a string to the current source directory.
@meson::get_compiler:
Returns a `compiler` object describing a compiler.
@meson::get_cross_property:
Returns the given property from a cross file, the optional fallback_value is returned if not cross compiling or the given property is not found.
@meson::get_external_property:
Returns the given property from a native or cross file. The optional fallback_value is returned if the given property is not found.
@meson::global_build_root:
Returns a string with the absolute path to the build root directory. This function will return the build root of the main project if called from a subproject, which is usually not what you want. It is usually preferable to use `meson.current_build_dir()` or `meson.project_build_root()`.
@meson::global_source_root:
Returns a string with the absolute path to the source root directory. This function will return the source root of the main project if called from a subproject, which is usually not what you want. It is usually preferable to use `meson.current_source_dir()` or `meson.project_source_root()`.
@meson::has_exe_wrapper:
Use `meson.can_run_host_binaries()` instead.
@meson::has_external_property:
Checks whether the given property exist in a native or cross file.
@meson::install_dependency_manifest:
Installs a manifest file containing a list of all subprojects, their versions and license names to the file name given as the argument.

If license files are defined as well, they will be copied next to the manifest and referenced in it.

If this function is not used, the builtin option `licensedir` can be used to install the manifest to a given directory with the name `depmf.json`.
@meson::is_cross_build:
Returns true if the current build is a cross build and false otherwise.
@meson::is_subproject:
Returns true if the current project is being built as a subproject of some other project and false otherwise.
@meson::is_unity:
Returns true when doing a unity build (multiple sources are combined before compilation to reduce build time) and false otherwise.
@meson::override_dependency:
Specifies that whenever `dependency()` with a specified name is used, Meson should bypass the system lookup and instead return `dep_object`. This object can be the result of `dependency()` or `declare_dependency()`.

This setup in a subproject enables the parent project to obtain the dependency without needing to know the specific dependency variable name. This can be achieved using: `dependency(name, fallback: subproject_name)`.
@meson::override_find_program:
Specifies that whenever `find_program()` is utilized to locate a program named `progname`, Meson should bypass the system lookup and instead return `program`. This `program` object can be the result of `find_program()`, `configure_file()`, or `executable()`.

Starting from Meson version 0.55.0, if a version check is provided to `find_program()` for a program that has been overridden with an executable, the current project version is utilized.
@meson::project_build_root:
Returns a string with the absolute path to the build root directory of the current (sub)project.
@meson::project_license:
Returns the array of licenses specified in `project()` function call.
@meson::project_license_files:
Returns the array of license files specified in the `project()` function call.
@meson::project_name:
Returns the project name specified in the `project()` function call.
@meson::project_source_root:
Returns a string with the absolute path to the source root directory of the current (sub)project.
@meson::project_version:
Returns the version string specified in `project()` function call.
@meson::source_root:
Returns a string with the absolute path to the source root directory.

This function will return the source root of the parent project if called from a subproject, which is usually not what you want. Try using `meson.current_source_dir()` or `meson.project_source_root()`. In the rare cases where the root of the main project is needed, use `meson.global_source_root()` that has the same behavior but with a more explicit name.
@meson::version:
Return a string with the version of Meson.
@module::found:
Returns true if the module was successfully imported, otherwise false.
@pkgconfig_module::generate:
Generates a pkg-config file
@python3_module::find_python:
This is a cross platform way of finding the Python 3 executable, which may have a different name on different operating systems. Returns an `external_program` object.
@python3_module::extension_module:
Creates a `shared_module` target that is named according to the naming conventions of the target platform. All positional and keyword arguments are the same as for `shared_module()`.

`extension_module` does not add any dependencies to the library, so the user may need to add dependencies using `dependency('python3')`.
@python3_module::language_version:
Returns a string with the Python language version such as `3.5`.
@python3_module::sysconfig_path:
Returns the Python sysconfig path without prefix, such as `lib/python3.6/site-packages`.
@python_installation::path:
Works like the path method of other `ExternalProgram` objects.
@python_installation::extension_module:
Create a `shared_module()` target that follows the target platform's naming conventions. All positional and keyword arguments are the same as for `shared_module()`, excluding `name_suffix` and `name_prefix`. Additionally, it includes the following:

- `subdir`: By default, Meson installs the extension module in the relevant top-level location for the Python installation, e.g., `/usr/lib/site-packages`. When `subdir` is passed to this method, it will be appended to that location. This keyword argument is mutually exclusive with `install_dir`.
- `limited_api`: Since 1.3.0, a string containing the Python version of the `Py_LIMITED_API` that the extension targets. For example, '3.7' to target Python 3.7's version of the limited API. This behavior can be disabled by setting the value of `python.allow_limited_api`. See Python module options.

Additionally, the following differs from `shared_module()`'s default behavior:

- `gnu_symbol_visibility`: If unset, it defaults to 'hidden' on versions of Python that support this (the python headers define `PyMODINIT_FUNC` has default visibility).

Since 0.63.0, `extension_module` automatically adds a dependency to the library if one is not explicitly provided. To support older versions, the user may need to add `dependencies : py_installation.dependency()`, see `dependency()`.
@python_installation::dependency:
This method accepts no positional arguments, and the same keyword arguments as the standard `dependency()` function.
@python_installation::install_sources:
Install actual python sources (.py).

All positional and keyword arguments for this function are the same as for `install_data()`, with the addition of the following:

- `python.platlibdir` and `python.purelibdir` options, available since 0.60.0, control the default installation path. See Python module options.
- `pure`: On certain platforms, architecture-independent files are typically placed in a separate directory. However, if the Python sources should be installed alongside an extension module built with this module, this keyword argument can be used to override that behavior. Defaults to the value specified in `find_installation()`, or else `true`.
- `subdir`: Refer to the documentation for the argument of the same name in `extension_module()`.
- `install_tag` (since 0.60.0): A string used by `meson install --tags` command to install only a subset of the files. By default, it has the tag `python-runtime`.
@python_installation::get_install_dir:
Retrieve the directory `install_sources()` will install to.
@python_installation::language_version:
Get the major.minor python version, e.g. `2.7`.
The version is obtained through the `sysconfig` module.
This function expects no arguments or keyword arguments.
@python_installation::get_path:
Get a path as defined by the `sysconfig` module.
@python_installation::has_path:
Returns true if a path named `path_name` can be retrieved with `get_path()`, false otherwise.
@python_installation::get_variable:
Get a variable as defined by the `sysconfig` module.
@python_installation::has_variable:
Returns true if a variable named `variable_name` can be retrieved with `get_variable()`, false otherwise.
@python_module::find_installation:
Find a Python installation matching `name_or_path`.

The `name_or_path` argument is optional. If not provided, the returned Python installation will be the one used to run Meson.

If provided, `name_or_path` can be:

- A simple name, e.g., `python-2.7`. Meson will look for an external program named that way using `find_program()`.
- A path, e.g., `/usr/local/bin/python3.4m`.
- One of `python2` or `python3`: In either case, the module will try some alternative names like `py -2` or `py -3` on Windows, and `python` everywhere. In the latter case, it will check whether the version provided by the `sysconfig` module matches the required major version.
- Since 1.2.0, searching for a minor version (e.g., `python3.11`) also works on Windows.
@qt4_module::compile_resources:
Compiles Qt's resources collection files (`.qrc`) into c++ files for compilation.
@qt4_module::compile_ui:
Compiles Qt's ui files (`.ui`) into header files.
@qt4_module::compile_moc:
Compiles Qt's moc files (`.moc`) into header and/or source files. At least one of the keyword arguments `headers` and `sources` must be provided.
@qt4_module::preprocess:
Consider using `compile_resources`, `compile_ui`, and `compile_moc` instead.

This function takes sources for `moc`, `uic`, and `rcc`, and converts them into C++ files for compilation.
@qt4_module::compile_translations:
This method generates the necessary targets to build translation files with `lrelease`.
@qt4_module::has_tools:
This method returns `true` if all tools used by this module are found, otherwise `false`.

It should be used to compile optional Qt code.
@qt5_module::compile_resources:
Compiles Qt's resources collection files (`.qrc`) into c++ files for compilation.
@qt5_module::compile_ui:
Compiles Qt's ui files (`.ui`) into header files.
@qt5_module::compile_moc:
Compiles Qt's moc files (`.moc`) into header and/or source files. At least one of the keyword arguments `headers` and `sources` must be provided.
@qt5_module::preprocess:
Consider using `compile_resources`, `compile_ui`, and `compile_moc` instead.

This function takes sources for `moc`, `uic`, and `rcc`, and converts them into C++ files for compilation.
@qt5_module::compile_translations:
This method generates the necessary targets to build translation files with `lrelease`.
@qt5_module::has_tools:
This method returns `true` if all tools used by this module are found, otherwise `false`.

It should be used to compile optional Qt code.
@qt6_module::compile_resources:
Compiles Qt's resources collection files (`.qrc`) into c++ files for compilation.
@qt6_module::compile_ui:
Compiles Qt's ui files (`.ui`) into header files.
@qt6_module::compile_moc:
Compiles Qt's moc files (`.moc`) into header and/or source files. At least one of the keyword arguments `headers` and `sources` must be provided.
@qt6_module::preprocess:
Consider using `compile_resources`, `compile_ui`, and `compile_moc` instead.

This function takes sources for `moc`, `uic`, and `rcc`, and converts them into C++ files for compilation.
@qt6_module::compile_translations:
This method generates the necessary targets to build translation files with `lrelease`.
@qt6_module::has_tools:
This method returns `true` if all tools used by this module are found, otherwise `false`.

It should be used to compile optional Qt code.
@runresult::compiled:
If true, the compilation succeeded, if false it did not and the other methods return unspecified data. This is only available for `compiler.run()` results.
@runresult::returncode:
The return code of executing the compiled binary
@runresult::stderr:
The standard error produced when the command was run.
@runresult::stdout:
The standard out produced when the command was run.
@rust_module::proc_macro:
This function creates a Rust proc-macro crate, similar to:
```meson
shared_library()(name, sources,
  rust_crate_type: 'proc-macro',
  native: true)
```
proc-macro targets can be passed to the `link_with` keyword argument of other Rust targets.

Only a subset of `shared_library()` keyword arguments are allowed:

- `rust_args`
- `rust_dependency_map`
- `sources`
- `dependencies`
- `extra_files`
- `link_args`
- `link_depends`
- `link_with`
- `override_options`

@rust_module::test:
This function creates a new rust unittest target from an existing rust based target,
which may be a library or executable. It does this by copying the sources and arguments passed to the original target and adding the `--test` argument to the compilation, then creates a new test target which calls that executable, using the rust test protocol.
@rust_module::bindgen:
This function wraps bindgen to simplify creating Rust bindings around C libraries. It offers two advantages over invoking bindgen with a generator or custom_target:

- It handles `include_directories`, eliminating the need to manually convert them to `-I...`.
- It automatically sets up a depfile, making the results more reliable.
- It automatically handles assertions, ensuring synchronization between Rust and C/C++ for consistent behavior.
@simd_module::check:
The module provides one method, `check()`, which is used like this:

```meson
rval = simd.check('mysimds',
  mmx : 'simd_mmx.c',
  sse : 'simd_sse.c',
  sse2 : 'simd_sse2.c',
  sse3 : 'simd_sse3.c',
  ssse3 : 'simd_ssse3.c',
  sse41 : 'simd_sse41.c',
  sse42 : 'simd_sse42.c',
  avx : 'simd_avx.c',
  avx2 : 'simd_avx2.c',
  neon : 'simd_neon.c',
  compiler : cc)
```
Generating code to detect the proper instruction set at runtime is straightforward. First you create a header with the configuration object and then a chooser function that looks like this:
```c
void (*fptr)(type_of_function_here)  = NULL;

#if HAVE_NEON
if(fptr == NULL && neon_available()) {
    fptr = neon_accelerated_function;
}
#endif
#if HAVE_AVX2
if(fptr == NULL && avx2_available()) {
    fptr = avx_accelerated_function;
}
#endif

...

if(fptr == NULL) {
    fptr = default_function;
}
```
Each source file provides two functions, the `xxx_available` function to query whether the CPU currently in use supports the instruction set and `xxx_accelerated_function` that is the corresponding accelerated implementation.

At the end of this function the function pointer points to the fastest available implementation and can be invoked to do the computation.
@source_configuration::sources:
Return the source files corresponding to the applied configuration.
@source_configuration::dependencies:
Return the dependencies corresponding to the applied configuration.
@sourceset::add:
To add a rule to a source set, you can use the `apply()` method. This method determines the conditions under which certain source files or dependency objects are included in a build configuration. All source files must exist in the source tree or can be generated in the build tree through methods like `configure_file()`, `custom_target`, or `generator`.

The `apply()` method takes `varnames_and_deps`, a list of conditions for the rule, which can be either strings or dependency objects. If all the strings evaluate to true and all dependencies are found, the rule will evaluate to true. Then, `apply()` will include the contents of the `if_true` keyword argument in its result. Otherwise, if any of the strings in the positional arguments evaluate to false or any dependency is not found, `apply()` will instead use the contents of the `if_false` keyword argument.

Dependencies can also appear in `sources_and_deps`. In this case, a missing dependency will simply be ignored and will not disable the rule, similar to how the `dependencies` keyword argument works in build targets.

**Note:** It's generally advisable to avoid mixing source sets and disablers. Disablers will cause the rule to be dropped altogether, and the `list_of_alt_sources` would not be taken into account anymore.
@sourceset::add_all:
Add one or more source sets to another.
@sourceset::all_sources:
Returns a list of all sources that were placed in the source set using `add` (including nested source sets) and that do not have a not-found dependency. If a rule has a not-found dependency, only the `if_false` sources are included (if any).
@sourceset::all_dependencies:
Returns a list of all dependencies that were placed in the source set using `add` (including nested source sets) and that were found.
@sourceset::apply:
Match the source set against a dictionary or a configuration_data object and return a source configuration object. A source configuration object allows you to retrieve the sources and dependencies for a specific configuration.

By default, all the variables that were specified in the rules have to be present in conf_data. However, in some cases the convention is that false configuration symbols are absent in conf_data; this is the case for example when the configuration was loaded from a Kconfig file. In that case you can specify the strict: false keyword argument, which will treat absent variables as false.
@sourceset_module::source_set:
Create and return a new source set object.
@str::contains:
Returns true if string contains the string specified as the argument.
@str::endswith:
Returns true if string ends with the string specified as the argument.
@str::format:
Strings can be built using the string formatting functionality.
@str::join:
The opposite of split, for example `'.'.join(['a', 'b', 'c'])` yields `'a.b.c'`.
@str::replace:
Search all occurrences of `old` and replace it with `new`.
@str::split:
Splits the string at the specified character (or whitespace if not set) and returns the parts in an array.
@str::splitlines:
Splits the string into an array of lines. Unlike `.split('\n')`, the empty string produces an empty array, and if the string ends in a newline, `splitlines()` doesn't split on that last newline. `\n`, `\r`, and `\r\n` are all considered newlines.
@str::startswith:
Returns true if string starts with the string specified as the argument.
@str::strip:
Removes leading/ending characters from the string.

By default the characters to remove are spaces and newlines.
@str::substring:
Returns a substring specified from start to end. Both `start` and `end` arguments are optional, so, for example, `'foobar'.substring()` will return `'foobar'`.

The method accepts negative values, where negative `start` is relative to the end of string `len(string) - start`, as well as negative `end`.

If `start` or `end` are out of bounds, the position of the closest character will be used. If `start` is bigger than `end`, the result will be an empty substring.
@str::to_int:
Converts the string to an int and throws an error if it can't be
@str::to_lower:
Converts all characters to lower case
@str::to_upper:
Converts all characters to upper case
@str::underscorify:
Creates a string where every non-alphabetical non-number character is replaced with `_`.
@str::version_compare:
Does semantic version comparison.
@subproject::found:
Returns whether the subproject was successfully setup.
@subproject::get_variable:
Fetches the specified variable from inside the subproject. This is useful to, for instance, get a `declare_dependency()` from the subproject.

If the variable does not exist, the variable `fallback` is returned. If a fallback is not specified, then attempting to read a non-existing variable will cause a fatal error.
@wayland_module::scan_xml:
Returns a list of `custom_tgt` in the order source, client-side header, server-side header. Generated header files have the name `<name>-<client|server>-protocol.h`.
@wayland_module::find_protocol:
This function requires one positional argument: the protocol base name. It returns a `file` that can be passed to `scan_xml`.
@windows_module::compile_resources:
Compiles Windows `rc` files specified in the positional arguments. Returns a list of `CustomTarget` objects that you put in the list of sources for the target you want to have the resources in.
